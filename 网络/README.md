## 网络相关笔记

***

### TCP/IP网络模式

* 应用层
* 传输层
    - 两个传输协议：TCP(传输控制协议)和UDP
    - TCP特性：流量控制、超时重传、拥塞控制等；TCP最大报文段长度MSS
* 网络层
  结构： IP头部 TCP头部 数据块1
    - IP协议，将传输层的报文作为数据部分，再加上IP包头组装成IP报文，如果IP
      报文大小超过MTU（以太网中一般为1500字节）就会再次进行切片
    - 寻址
    - 路由
* 网络接口层
  通过MAC头部判断网络包目的地

***

#### TCP三次握手

SYN:建立连接 FIN:关闭连接 ACK:响应 PSH:有数据传输 RST:连接重置

* 客户端发起连接SYN，随机一个初始化序列号seq=x,设置SYN=1表示握手报文，
  之后处于SYN-SENT（同步已发送）状态
* 服务端收到发起的连接，随机生成一个初始序列号（server_isn）(seq=y),
  设置ack=x+1,设置SYN=1和ACK=1，表示是一个SYN握手和ACK确认应答报文，
  返回SYN，并且ACK客户端SYN，之后处于SYN-RCVD（同步已接收）状态
* 客户端收到服务端发送的SYN和ACK之后，将ACK置为1，表示是一个应答报文，设置ack=y+1，
  表示收到了服务器的y之前的数据，发送对SYN确认的ACK，之后处于ESTABLISHED（连接已建立）状态，因为
  已经一发一送成功了,这次报文可以携带客户端到服务端的数据。
* 服务端收到ACK之后，处于ESTABLISHED状态，因为也已经一发一送状态

***

### HTTP(超文本传输协议)

#### 状态码

* 1 XX 提示信息，是协议处理中的一种中间状态
* 2 XX 服务器成功处理了客户端的请求
    - 200 成功
    - 204 No Content 响应头没有body数据
    - 206 Partial Content应用于HTTP分块下载或断点续传，表示响应的返回的body数据并不是资源的全部，只是一部分，
      也是服务器处理成功的状态
* 3 XX 客户端请求的资源发生了变动，需要客户端用新的URL重新发送请求获取资源，也就是重定向
    - 301 永久重定向，请求资源已经不存在，需改用新的URL再次访问
    - 302 Found 表示临时重定向，请求的资源还在，暂时需要用另一个URL访问
    - 304 Not Modified 不具有跳转的含义，资源未修改，重定向到已存在的缓冲文件，也称缓存重定向，
      告诉客户端可以继续使用缓存资源，用于缓存控制
* 4 XX 客户端发送的报文有误，服务器无法处理
    - 400 Bad Request表示客户端请求的报文有错误
    - 401 未授权
    - 403 Forbidden表示服务器禁止访问资源
    - 404 Not Found表示请求的资源不存在
* 5 XX 客户端请求报文正确，但是服务器处理时内部发生了错误
    - 500 服务器发生错误
    - 501 客户端请求的功能还不支持
    - 502 网关或代理时返回的错误码
    - 503 服务器很忙，暂时无法响应客户端

#### 常见字段

Host、 Content-Length(返回数据的长度)、 Connection(使用Tcp持久连接，以便请求复用，Keep-Alive)、
Content-Type(数据格式：text/html;chatset=utf-8)、 Content-encoding(数据压缩方法)、

***

#### GET和POST方法是否是安全和幂等的吗（RFC规范）？

* GET方法获取指定的资源，是安全、幂等、可被缓存的（只读操作）
* POST是新增或提交数据的操作，不安全，不是幂等的，不可缓存
* HTTP传输的内容都是明文的，使用https数据会被加密传输

#### HTTP/2、HTTP/1.1、HTTP/1.0、HTTP/3区别

* http/1.1使用长连接方式、支持管道（pipeline）网络传输，管道问题：没有解决响应的对头阻塞，服务端
  需要按顺序响应收到的请求
* http/2会压缩头，多个请求会消除重复部分（HPACK）
* http/2全面采用二进制格式：头信息帧和数据帧
* http/2每个请求或响应的所有数据包称为数据流都有一个Stream ID,客户端
  建立的stream必须是奇数号，服务器建立的stream必须是偶数号，可以指定stream的优先级
* http/2可以在一个连接中并发多个请求或回应（多路复用）
* http/2服务器推送
* http/2问题：tcp对头阻塞问题，tcp层必须保证收到的字节数据是完整且连续的，当前一个字节
  没有到达时，后收到的字节数据只能存放在内核缓冲区，只有等到这一个字节到达时，http/2应用层才能从
  内核中拿到数据。
* http/3将HTTP下层的TCP协议改成了UDP，增加QUIC协议实现类似TCP的可靠性传输。

***

##### QUIC协议特点

* 无队头阻塞：可以在同一连接上并发传输多个stream，当某个stream丢包是，只会阻塞这个流，其他不收到影响
* 更快的连接建立：握手过程只需要1RTT，确认双方的连接id。QUIC包含TLS协议
* 连接迁移，通过连接id标记通信的两个断点

***

### TLS协议

https是在http与tcp层之间加入了tls协议

* 客户端发出Client Hello消息包含：TLS版本号、支持的密码套件列表、随机数
* 服务端收到消息后，缺人TLS版本号是否支持，从密码套件列表中选择一个密码套件，生成随机数；
  返回Server Hello消息，包含：确认的TLS版本号、服务器随机数、密码套件、Server Certificat
  包含数字证书
* 客户端验证证书，生成一个新的随机数，用服务器的rsa公钥加密该随机数，通过Change Cipher Key Exchange消息传给服务器
  服务端收到消息后用RSA私钥解密，得到客户端的随机数，根据三个随机数生成会话密钥，发一个Change Cipher Spec
  客户端将之前所有发送数据，使用会话密钥加密，让服务器验证加密通信是否可用
* 服务端同样Change Cipher Spec，Encrypted Handshake Message 验证加密解密，握手正式完成

***

### TCP头格式

TCP是面向连接、可靠的、基于字节流的传输层通信协议

* 序列号：在建立连接时生成的随机数作为其初始值，通过SYN（建立连接）包传给接收端，没发送一次数据就累加
  一次该数据字节数的大小。用来解决网络包乱序问题。
* 确认应答号：指下一次期望收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都
  已经被正常接收。用来解决丢包。
* 控制位：
    - ACK: 该位为1时，确认应答的字段变为有效，TCP规定除了最初建立连接时的SYN包之外该位必须设置为1.
    - RST：该位为1时，表示TCP连接中出现异常必须强制断开连接。
    - SYN：该位为1时，表示希望建立连接，并在其序列号的字段进行序列号初始值的设定。
    - FIN：该位为1时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的
      主机之间就可以相互交换FIN位为1的TCP段。

#### 三次握手的原因

* 阻止重复历史连接的初始化
    - 客户端异常情况或者网络阻塞情况，旧的SYN报文比新的SYN报文早到达服务端
      会返回SYN+ACK报文给客户端，客户端会比较自身上下文（序列号+1），会发送RST报文给服务端，中止这一次的连接。
* 同步双方的初始序列号
    - 接收方可以去除重复数据；
    - 接收方可以根据数据包的序列号按序接收
    - 可以标识发送出去的数据包中，那些是被对方接收的（ACK报文中的序列号）
* 避免资源浪费
    - 避免SYN阻塞，重复发送多次SYN报文，服务器建立多个冗余的无效链接，造成不必要的资源浪费。

#### MTU和MSS

* MTU:一个网络包的最大长度，以太网中一般为1500字节；
* MSS:出去IP和TCP头部之后，一个网络报所能容纳的TCP数据的最大长度；

### TCP连接断开（四次挥手过程和状态变迁）

* 客户端关闭连接会发送一个TCP首部FIN标志位被置为1的报文，FIN报文，之后客户端进入**FIN_WAIT_1**状态
* 服务端收到FIN报文后，发送ACK应答报文，接着服务端进入**CLOSED_WAIT**状态
* 客户端收到服务端的ACK应答报文后，进入**FIN_WAIT_2**状态
* 服务端处理完数据后，向客户端发送FIN报文，之后进入**LAST_WAIT**状态
* 客户端收到服务端的FIN报文后，回一个ACK应答报文，之后进入TIME_WAIT状态
* 服务器收到了ACK应答报文后，就进入CLOSED状态，至此服务器已经完成连接的关闭
* 客户端在经过2MSL一段时间后，自动进入CLOSED状态，至此客户端也完成连接的关闭

#### TIME_WAIT的等待时间为什么是2MSL？

主动发起关闭连接的一方才会有TIME_WAIT状态

* MSL最大报文生存时间，是在网络上存在的最长时间，超过这个时间就会被丢弃。
  IP头中有一个ttl字段，是IP数据报可以经过的最大路由数，每经过一个路由减1，
  为0则数据报将被丢弃。
* 区别：MSL的单位是时间，TTL是经过的路由跳数，MSL应该要大于
  或等于TTL消耗为0的时间，以确保报文已被自然消亡。
* TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，
  意味着Linux认为数据报文经过 64 个路由器的时间不会超过 30 秒，
  如果超过了，就认为报文已经消失在网络中了。
* TIME_WAIT 等待 2 倍的 MSL(60秒)，比较合理的解释是： 网络中可能存在来自发送方的数据包，
  当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。

#### 为什么需要TIME_WAIT状态

* 防止历史连接的中数据，被后面相同的四元组的连接错误的接收，保证两个方向的数据包在2MSL被丢弃。
* 保证被动关闭连接的一方，能被正确关闭。最后一次ACK报文直接进入CLOSED状态，如果报文丢失，服务端
  重传FIN报文，就会返回RST报文

#### 优化TIME_WAIT

* net.ipv4.tcp_tw_reuse和tcp_timestamps;调用connect函数时，随机找一个time_wait
  状态超过1秒的连接给新的连接复用；前提条件打开对tcp时间戳的支持。
* net.ipv4.tcp_max_tw_buckets默认18000，time_wait超过这个值，将后面的TIME_WAIT
  连接状态重置。
* 程序中使用SO_LINGER,l_onoff为非0且l_linger值为0，那么调用close后，会立刻发送一个RST
  标志给对端，跳过四次挥手直接关闭

***

### TCP重传机制、滑动窗口、流量控制、拥塞控制

* 重传机制
    - 超时重传：设定计时器，没有收到对方ACK确认报文，就重发。（数据包丢失、确认应答丢失）
        + RTO:超时重传时间，每当遇到一次超市重传的时候，都会将下一次超时时间设为先前值的两倍。
        + RTT:数据发送时刻到接收到确认的时刻的差值，包的往返时间。TCP采样RTT的时间，加权平均
          算出平滑RTT的值，采样RTT的波动范围。

* 滑动窗口
    - 操作系统开辟了一个缓存空间，发送方在等到确认应答返回之前，必须在缓冲区中保留已发送的数据
      ，如果按期收到确认应答，就可以从缓存区清除。窗口大小为3个TCP端，那么发送方就可以连续发送3个TCP段
      如果其中一个确认应答丢失，可以通过下一个确认应答进行确认，只要收到后续的确认应答，意味着之前所有数
      据接收方都收到，这种模式叫累计确认或累计应答。
    - 窗口大小，tcp头中有一个字段叫window，也就是窗口大小，由接收方的窗口大小决定
        * 发送方窗口
            + SND.WND:表示发送窗口的大小（大小由接收方指定）
            + SND.UNA:是一个绝对指针，指向已发送但未收到确认的第一个字节的序列号
            + SND.NEXT:是一个绝对指针，指向未发送但可发送范围的第一个字节的序列号
            + 最后一个是相对指针，需要SND.UNA指针加上SND.WND大小的偏移量，就指向第四个的第一个字节
        * 接收方滑动窗口
            + RCV.WND:接收窗口大小，会通告给发送方
            + RCV.NXT:是一个指针，接收数据的第一个字节
            + 第三个是一个相对指针，RCV.NXT指针加上RCV.WND大小的偏移量，指向未收到并不可以接收的数据第一个字节
        * 接收窗口大小约等于发送窗口的大小，当接收方有接收窗口空缺出来，就会通过TCP报文中windows告诉发送方
* 流量控制
    - 避免因为接收方处理数据影响，导致触发重发机制，导致网络流量无端的浪费
    - 窗口探测报文，TCP连接一方收到对方的零窗口通知，就启动持续计时器。如果持续计时器超时，就会发送窗口探测报文，告知对方
      接收窗口大小，如果扔为0，重新启动持续计时器。一般为3次每次大约30-60s，3次过后还是0，TCP就会发RST报文
* 拥塞控制，网络出现堵塞的情况，发送大量数据包，可能会导致包时延、丢失等
    - 拥塞窗口cwnd是发送方维护的一个状态变量，发送方没有在规定时间内接收到ACK应答报文，发生了超时重传，就会认为网络出现了
      拥塞。
    - 拥塞控制算法
        + 慢启动：一点一点提高发送数据包的数量，没收到一个ACK，拥塞窗口cwnd的大小就会加1
        + 拥塞避免：当拥塞窗口超过慢起动门限ssthresh（65535）就会进入拥塞避免算法
        + 拥塞发生
        + 快速恢复

###　TCP优化

#### 三次握手优化

* 客户端根据网络稳定性和目标服务器的繁忙程度修改SYN的重传次数，调整客户端的三次握手时间上限。
* 服务端会建立一个半连接队列来维护未完成的握手信息
