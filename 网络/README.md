## 网络相关笔记

***

### TCP/IP网络模式

* 应用层
* 传输层
    - 两个传输协议：TCP(传输控制协议)和UDP
    - TCP特性：流量控制、超时重传、拥塞控制等；TCP最大报文段长度MSS
* 网络层
  结构： IP头部 TCP头部 数据块1
    - IP协议，将传输层的报文作为数据部分，再加上IP包头组装成IP报文，如果IP
      报文大小超过MTU（以太网中一般为1500字节）就会再次进行切片
    - 寻址
    - 路由
* 网络接口层
  通过MAC头部判断网络包目的地

***

#### TCP三次握手

SYN:建立连接 FIN:关闭连接 ACK:响应 PSH:有数据传输 RST:连接重置

* 客户端发起连接SYN，随机一个初始化序列号seq=x,设置SYN=1表示握手报文，
  之后处于SYN-SENT（同步已发送）状态
* 服务端收到发起的连接，随机生成一个初始序列号（server_isn）(seq=y),
  设置ack=x+1,设置SYN=1和ACK=1，表示是一个SYN握手和ACK确认应答报文，
  返回SYN，并且ACK客户端SYN，之后处于SYN-RCVD（同步已接收）状态
* 客户端收到服务端发送的SYN和ACK之后，将ACK置为1，表示是一个应答报文，设置ack=y+1，
  表示收到了服务器的y之前的数据，发送对SYN确认的ACK，之后处于ESTABLISHED（连接已建立）状态，因为
  已经一发一送成功了,这次报文可以携带客户端到服务端的数据。
* 服务端收到ACK之后，处于ESTABLISHED状态，因为也已经一发一送状态

***

### HTTP(超文本传输协议)

#### 状态码

* 1 XX 提示信息，是协议处理中的一种中间状态
* 2 XX 服务器成功处理了客户端的请求
    - 200 成功
    - 204 No Content 响应头没有body数据
    - 206 Partial Content应用于HTTP分块下载或断点续传，表示响应的返回的body数据并不是资源的全部，只是一部分，
      也是服务器处理成功的状态
* 3 XX 客户端请求的资源发生了变动，需要客户端用新的URL重新发送请求获取资源，也就是重定向
    - 301 永久重定向，请求资源已经不存在，需改用新的URL再次访问
    - 302 Found 表示临时重定向，请求的资源还在，暂时需要用另一个URL访问
    - 304 Not Modified 不具有跳转的含义，资源未修改，重定向到已存在的缓冲文件，也称缓存重定向，
      告诉客户端可以继续使用缓存资源，用于缓存控制
* 4 XX 客户端发送的报文有误，服务器无法处理
    - 400 Bad Request表示客户端请求的报文有错误
    - 403 Forbidden表示服务器禁止访问资源
    - 404 Not Found表示请求的资源不存在
* 5 XX 客户端请求报文正确，但是服务器处理时内部发生了错误
    - 500 服务器发生错误
    - 501 客户端请求的功能还不支持
    - 502 网关或代理时返回的错误码
    - 503 服务器很忙，暂时无法响应客户端

#### 常见字段

Host、 Content-Length(返回数据的长度)、 Connection(使用Tcp持久连接，以便请求复用，Keep-Alive)、
Content-Type(数据格式：text/html;chatset=utf-8)、 Content-encoding(数据压缩方法)、

***

#### GET和POST方法是否是安全和幂等的吗（RFC规范）？

* GET方法获取指定的资源，是安全、幂等、可被缓存的（只读操作）
* POST是新增或提交数据的操作，不安全，不是幂等的，不可缓存
* HTTP传输的内容都是明文的，使用https数据会被加密传输

#### HTTP/2、HTTP/1.1、HTTP/1.0、HTTP/3区别

* http/1.1使用长连接方式、支持管道（pipeline）网络传输，管道问题：没有解决响应的对头阻塞，服务端
  需要按顺序响应收到的请求
* http/2会压缩头，多个请求会消除重复部分（HPACK）
* http/2全面采用二进制格式：头信息帧和数据帧
* http/2每个请求或响应的所有数据包称为数据流都有一个Stream ID,客户端
  建立的stream必须是奇数号，服务器建立的stream必须是偶数号，可以指定stream的优先级
* http/2可以在一个连接中并发多个请求或回应（多路复用）
* http/2服务器推送
* http/2问题：tcp对头阻塞问题，tcp层必须保证收到的字节数据是完整且连续的，当前一个字节
  没有到达时，后收到的字节数据只能存放在内核缓冲区，只有等到这一个字节到达时，http/2应用层才能从
  内核中拿到数据。
* http/3将HTTP下层的TCP协议改成了UDP，增加QUIC协议实现类似TCP的可靠性传输。

***

##### QUIC协议特点

* 无队头阻塞：可以在同一连接上并发传输多个stream，当某个stream丢包是，只会阻塞这个流，其他不收到影响
* 更快的连接建立：握手过程只需要1RTT，确认双方的连接id。QUIC包含TLS协议
* 连接迁移，通过连接id标记通信的两个断点

***

### TLS协议

https是在http与tcp层之间加入了tls协议

* 客户端发出Client Hello消息包含：TLS版本号、支持的密码套件列表、随机数
* 服务端收到消息后，缺人TLS版本号是否支持，从密码套件列表中选择一个密码套件，生成随机数；
  返回Server Hello消息，包含：确认的TLS版本号、服务器随机数、密码套件、Server Certificat
  包含数字证书
* 客户端验证证书，生成一个新的随机数，用服务器的rsa公钥加密该随机数，通过Change Cipher Key Exchange消息传给服务器
  服务端收到消息后用RSA私钥解密，得到客户端的随机数，根据三个随机数生成会话密钥，发一个Change Cipher Spec
  客户端将之前所有发送数据，使用会话密钥加密，让服务器验证加密通信是否可用
* 服务端同样Change Cipher Spec，Encrypted Handshake Message 验证加密解密，握手正式完成

***

### TCP头格式

TCP是面向连接、可靠的、基于字节流的传输层通信协议

* 序列号：在建立连接时生成的随机数作为其初始值，通过SYN（建立连接）包传给接收端，没发送一次数据就累加
  一次该数据字节数的大小。用来解决网络包乱序问题。
* 确认应答号：指下一次期望收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都
  已经被正常接收。用来解决丢包。
* 控制位：
    - ACK: 该位为1时，确认应答的字段变为有效，TCP规定除了最初建立连接时的SYN包之外该位必须设置为1.
    - RST：该位为1时，表示TCP连接中出现异常必须强制断开连接。
    - SYN：该位为1时，表示希望建立连接，并在其序列号的字段进行序列号初始值的设定。
    - FIN：该位为1时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的
      主机之间就可以相互交换FIN位为1的TCP段。

#### 三次握手的原因

* 阻止重复历史连接的初始化
    - 客户端异常情况或者网络阻塞情况，旧的SYN报文比新的SYN报文早到达服务端
      会返回SYN+ACK报文给客户端，客户端会比较自身上下文（序列号+1），会发送RST报文给服务端，中止这一次的连接。
* 同步双方的初始序列号
    - 接收方可以去除重复数据；
    - 接收方可以根据数据包的序列号按序接收
    - 可以标识发送出去的数据包中，那些是被对方接收的（ACK报文中的序列号）
* 避免资源浪费
    - 避免SYN阻塞，重复发送多次SYN报文，服务器建立多个冗余的无效链接，造成不必要的资源浪费。

#### MTU和MSS

* MTU:一个网络包的最大长度，以太网中一般为1500字节；
* MSS:出去IP和TCP头部之后，一个网络报所能容纳的TCP数据的最大长度；

### TCP连接断开（四次挥手过程和状态变迁）

* 客户端关闭连接会发送一个TCP首部FIN标志位被置为1的报文，FIN报文，之后客户端进入**FIN_WAIT_1**状态
* 服务端收到FIN报文后，发送ACK应答报文，接着服务端进入**CLOSED_WAIT**状态
* 客户端收到服务端的ACK应答报文后，进入**FIN_WAIT_2**状态
* 服务端处理完数据后，向客户端发送FIN报文，之后进入**LAST_WAIT**状态
* 客户端收到服务端的FIN报文后，回一个ACK应答报文，之后进入TIME_WAIT状态
* 服务器收到了ACK应答报文后，就进入CLOSED状态，至此服务器已经完成连接的关闭
* 客户端在经过2MSL一段时间后，自动进入CLOSED状态，至此客户端也完成连接的关闭

#### TIME_WAIT的等待时间为什么是2MSL？

* MSL最大报文生存时间，是在网络上存在的最长时间，超过这个时间就会被丢弃。
  IP头中有一个ttl字段，是IP数据报可以经过的最大路由数，每经过一个路由减1，
  为0则数据报将被丢弃。
* 区别：MSL的单位是时间，TTL是经过的路由跳数，MSL应该要大于
  或等于TTL消耗为0的时间，以确保报文已被自然消亡。
* TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，
  意味着Linux认为数据报文经过 64 个路由器的时间不会超过 30 秒，
  如果超过了，就认为报文已经消失在网络中了。
* TIME_WAIT 等待 2 倍的 MSL(60秒)，比较合理的解释是： 网络中可能存在来自发送方的数据包，
  当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。

